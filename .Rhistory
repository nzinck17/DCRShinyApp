guides(shape = guide_legend(nrow = 1))
p2leg <- get_legend(p2)
p <- grid.arrange(grobs = list(p1, p2leg), nrow = 2, ncol = 1,
heights = unit(c(10, 3), "cm"))
p2 <- ggplot() +
geom_point(data = df.shape, aes(x = Hey, y = Hey,  shape = Type)) +
scale_shape_manual(name="Hey", breaks = c("Param1", "Param2"),  values=c(16, 17)) +
guides(shape = guide_legend(nrow = 1))
p2leg <- get_legend(p2)
p <- grid.arrange(grobs = list(p1, p2leg), nrow = 2, ncol = 1,
heights = unit(c(10, 3), "cm"))
p
grid.arrange(grobs = list(p1, p2leg), nrow = 2, ncol = 1,
heights = unit(c(10, 3), "cm"))
runApp()
runApp()
runApp()
?grid.arrange
p2 <- ggplot() +
geom_point(data = df.shape, aes(x = Hey, y = Hey,  shape = Type)) +
scale_shape_manual(name="Hey", breaks = c("Param1", "Param2"),  values=c(16, 17)) +
guides(shape = guide_legend(nrow = 1))
p2leg <- get_legend(p2)
lay <- rbind(c(1,1,1,1,2),
c(1,1,1,1,2),
c(1,1,1,1,2))
p <- grid.arrange(grobs = list(p1, p2leg), layout_matrix = lay)
p
grid.arrange(grobs = list(p1, p2leg), layout_matrix = lay)
p2 <- ggplot() +
geom_point(data = df.shape, aes(x = Hey, y = Hey,  shape = Type)) +
scale_shape_manual(name="Hey", breaks = c("Param1", "Param2"),  values=c(16, 17)) +
guides(shape = guide_legend(nrow = 1))
p2leg <- get_legend(p2)
lay <- rbind(c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(1,2,2,1))
grid.arrange(grobs = list(p1, p2leg), layout_matrix = lay)
grid.arrange(grobs = list(p1, p2leg), layout_matrix = lay)
lay <- rbind(c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(NA,2,2,NA))
grid.arrange(grobs = list(p1, p2leg), layout_matrix = lay)
lay <- rbind(c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(NA,2,2,NA))
grid.arrange(grobs = list(p1, p2leg), layout_matrix = lay)
lay <- rbind(c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(NA,2,2,NA))
grid.arrange(grobs = list(p1, p2leg), layout_matrix = lay)
ggplot() +
geom_point(data = df.shape, aes(x = Hey, y = Hey,  shape = Type)) +
#scale_shape_manual(name="Hey", breaks = c("Param1", "Param2"),  values=c(16, 17)) +
#guides(shape = guide_legend(nrow = 1))
p2leg <- get_legend(p2)
lay <- rbind(c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(1,1,1,1),
c(NA,2,2,NA))
grid.arrange(grobs = list(p1, p2leg), layout_matrix = lay)
runApp()
p1 + guides(colour=FALSE)
p1.plot <- p1 + guides(colour=FALSE)
p1.leg <- get_legend(p1)
lay <- rbind(c(1,1,1,1,2),
c(1,1,1,1,3),
c(1,1,1,1,3),
c(1,1,1,1,3),
c(1,1,1,1,3))
grid.arrange(grobs = list(p1.plot, p1.leg, p2leg), layout_matrix = lay)
p2.leg <- get_legend(p2)
lay <- rbind(c(1,1,1,1,2),
c(1,1,1,1,3),
c(1,1,1,1,3),
c(1,1,1,1,3),
c(1,1,1,1,3))
grid.arrange(grobs = list(p1.plot, p2.leg, p1.leg), layout_matrix = lay)
lay <- rbind(c(1,1,1,1,2),
c(1,1,1,1,3),
c(1,1,1,1,3),
c(1,1,1,1,3),
c(1,1,1,1,3),
c(1,1,1,1,3),
c(1,1,1,1,3))
grid.arrange(grobs = list(p1.plot, p2.leg, p1.leg), layout_matrix = lay)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
# This script will run in a hidden rscript.exe session.
# 1.   nstall the packages that the Shiny App uses. This list will need to be appended as the app grows.
# ipak function: install and load multiple R packages.
# check to see if packages are installed. Install them if they are not, then load them into the R session.
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
# Set Library path for installantion
.libPaths("C:/Users/DCR-Tobiason/Documents/R/win-library/3.4")
# usage
ipak("shiny")
runApp()
shiny::runApp()
runApp()
# This script will run in a hidden rscript.exe session.
# 1.   nstall the packages that the Shiny App uses. This list will need to be appended as the app grows.
# ipak function: install and load multiple R packages.
# check to see if packages are installed. Install them if they are not, then load them into the R session.
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
# Set Library path for installantion
.libPaths("C:/Users/DCR-Tobiason/Documents/R/win-library/3.4")
# usage
ipak("shiny")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
data_frame(Type = c("Param1", "Param2"), Hey = c(1, 2)) %>% ggplot() +
geom_point(aes(x = Hey, y = Hey,  shape = Type))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?get_legend
?ggdraw
plot_grid
?plot_grid
runApp()
runApp()
mtcars
p <- ggplot(mtcars) %>% geom_point(x = mpg, y = cyl)
p.leg <- get_legend(p)
ggdraw(plot_grid(plot_grid(p, p.leg, ncol=1, align='v')))
p <- ggplot(mtcars) %>% geom_point(aes(x = mpg, y = cyl))
p.leg <- get_legend(p)
ggdraw(plot_grid(plot_grid(p, p.leg, ncol=1, align='v')))
ggplot(mtcars) %>% geom_point(aes(x = mpg, y = cyl))
mtcars
ggplot(mtcars, aes(x = mpg, y = cyl)) %>% geom_point()
p <- ggplot(mtcars) + geom_point(aes(x = mpg, y = cyl))
p.leg <- get_legend(p)
ggdraw(plot_grid(plot_grid(p, p.leg, ncol=1, align='v')))
p <- ggplot(mtcars) + geom_point(aes(x = mpg, y = cyl, colour = wt))
p.leg <- get_legend(p)
ggdraw(plot_grid(plot_grid(p, p.leg, ncol=1, align='v')))
ggdraw(plot_grid(p, p.leg, ncol=1))
ggdraw(plot_grid(p, p.leg, ncol=2))
ggdraw(plot_grid(p, p.leg, ncol=2))
plot_grid(p, p.leg, ncol=2)
ggdraw(plot_grid(p, p.leg, ncol=2))
?plot_grid
ggdraw(plot_grid(p, p.leg, ncol=2, rel_widths = c(5, 1)))
runApp()
runApp()
png(plot_grid(p, p.leg, ncol=2, rel_widths = c(5, 1)))
png("hey")
plot_grid(p, p.leg, ncol=2, rel_widths = c(5, 1))
dev.off
plot_grid(p, p.leg, ncol=2, rel_widths = c(5, 1))
png("F:/Nick Zinck/Shiny Water Quality/GitHub/DCRShinyApp")
plot_grid(p, p.leg, ncol=2, rel_widths = c(5, 1))
dev.off
png("F:/Nick Zinck/Shiny Water Quality/GitHub/DCRShinyApp")
ggdraw(plot_grid(p, p.leg, ncol=2, rel_widths = c(5, 1)))
dev.off
png("F:/Nick Zinck/Shiny Water Quality/GitHub/DCRShinyApp/hey.png")
ggdraw(plot_grid(p, p.leg, ncol=2, rel_widths = c(5, 1)))
dev.off
dev.off
shiny::runApp()
# check to see if packages are installed. Install them if they are not, then load them into the R session.
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
# Set Library path for installantion
.libPaths("C:/Users/DCR-Tobiason/Documents/R/win-library/3.4")
# usage
ipak("shiny")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
as.POSIXct("01-022017")
as.POSIXct("01-02-2017")
0.9*as.POSIXct("01-02-2017")
seq(as.POSIXct("01-02-2017"), as.POSIXct("02-02-2017"))
seq(as.POSIXct("01-02-2017"), as.POSIXct("02-02-2017"), by = "day")
quantile(seq(as.POSIXct("01-02-2017"), as.POSIXct("02-02-2017"), by = "day"), c(.9))
runApp()
runApp()
quantile(seq(as.POSIXct("01-02-2017"), as.POSIXct("02-02-2017"), by = "day"), c(.9, .95))
quantile(seq(as.POSIXct("01-02-2017"), as.POSIXct("02-02-2017"), by = "day"), c(.9, .95))[1]
quantile(seq(as.POSIXct("01-02-2017"), as.POSIXct("02-02-2017"), by = "day"), c(.9, .95))[2]
runApp()
runApp()
runApp()
?renderPlot
runApp()
runApp()
runApp()
runApp()
runApp()
?ggplot
runApp()
runApp()
runApp()
hey <- c("kjshdf", "kljahsdf", "kjhsd")
paste("kjh", paste(hey))
paste("kjh", paste(paste(hey)))
paste("kjh"), paste(paste(hey))
paste(paste("kjh"), paste(paste(hey)))
paste(paste("kjh"), paste(paste(hey)))
paste(paste("kjh"), paste(paste(hey, collapse = " ")))
paste(paste("kjh", collapse = ","))
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
View(df.chem.quab)
View(df.chem.wach)
View(df.bact.quab)
View(df.bact.wach)
View(df.chem.quab)
runApp()
runApp()
runApp()
?checkboxGroupInput
runApp()
runApp()
runApp()
map.plot <- function(input, output, session, df.full, df.filtered, df.site) {
### Dataframe filtered or full based on Selection
df <- reactive({
if(input$dfchoice == "filtered"){
df.filtered()
}else{
df.full
}
})
# Reactive Dataframe for data stats
df.react <- reactive({
# Filter by Parameter and remove NAs
df.temp <- df() %>%
filter(!is.na(Result),
Parameter %in% input$param)
# Filter by Date
if(input$year != "All Years"){
df.temp <- df.temp %>% filter(year(Date) == input$year)
}
if (input$month != "All Months"){
df.temp <- df.temp %>% filter(month(Date) == input$month)
}
# Group by Site and add any statistics (Make sure this matches with UI options)
df.temp <- df.temp %>% group_by(Site) %>%
summarise(average = mean(Result),
minimum = min(Result),
maximum = max(Result),
median = median(Result),
`1st quartile` = quantile(Result, 0.25),
`3rd quartile` = quantile(Result, 0.75),
variance = var(Result),
`stand.dev.` = sd(Result),
`number of samples` = n()) %>%
# Restructuring the Stat Columns into Two new Columns: "Stat" and "Value"
gather(Stat, Value, -c(Site))
# Create a more condensed Site Location dataframe (with Lat,lomg,site ID)
df.site.temp <- df.site %>%
select(Site, LocationLat, LocationLong)
# Join the two tables together mathched by site - now includes lat/long info
df.temp <- inner_join(df.temp, df.site.temp, "Site") %>%
filter(Stat %in% input$stat,
!is.na(LocationLat),
!is.na(LocationLong))
# Setting a 3 digit sig fig for Statistic Values
df.temp$Value <- signif(df.temp$Value, 3)
# Assiging df.temp to df.react
df.temp
}) # end df.react
# Map - Color Pallete
colorpal <- reactive({
# If statement to prevent potential cras, See Note 1
if(nrow(df.react()) > 0){
colorNumeric(palette = input$color.dynamic, range(df.react()$Value))
}
}) # end colorpal
# Map - Size "Pallete" - For size legend creation.
value.min <- reactive({
signif(min(df.react()$Value),3)
})
value.max <- reactive({
signif(max(df.react()$Value),3)
})
# Create 8 circles for the legend. change 8 if desired number is different
value.list <- reactive({
signif(seq(value.min(), value.max(), length.out = 8), 3)
})
# Sizing Scheme for the Circles, See Note 2
value.scale <- reactive({
((as.numeric(input$radius)*30)+10)/sqrt(value.max())
})
diam.list <- reactive({
2*value.scale()*sqrt(value.list())
})
# Base Leaflet Map - See Note 3
output$map <- renderLeaflet({
leaflet(data = df.site %>% filter(!is.na(LocationLat), !is.na(LocationLong))) %>%
addProviderTiles(providers$Stamen.TonerLite,
options = providerTileOptions(noWrap = TRUE)) %>%
fitBounds(~min((LocationLong)), ~min(LocationLat), ~max(LocationLong), ~max(LocationLat))
})
# Circle Legend function
addLegendCustom <- function(map, colors, labels, sizes, opacity = 0.5){
colorAdditions <- paste0(colors, "; width:", sizes, "px; height:", sizes, "px")
labelAdditions <- paste0("<div style='display: inline-block;height: ", sizes,
"px;margin-top: 4px;line-height: ", sizes, "px;'>", labels, "</div>")
return(addLegend(map, colors = colorAdditions, labels = labelAdditions, opacity = opacity))
}
# Map Proxy - Add the Circle Markers and Legend to the map. This is Reactive to events, unlike the Base Map.
observe({
# if Data Selected is empty, do not add markers. See Note 1
if(nrow(df.react()) > 0){
# Color
if(input$plot.type == "Display by Color"){
pal <- colorpal()                                # load colorpal function
leafletProxy("map", data = df.react()) %>%
clearTiles() %>%
addProviderTiles(input$map.type,
options = providerTileOptions(noWrap = TRUE)) %>%
clearMarkers() %>%
addCircleMarkers(lng = ~LocationLong,
lat = ~LocationLat,
radius = input$radius*15+5,          # user selected opacity
weight = .5,                         # weight of the outside circle
color = "black",                     # color of the outside circle
fillColor = ~pal(Value),             # color inside
fillOpacity = input$opacity,         # user selected opacity
label= ~as.character(Value),         # show Value when hovering
popup = ~Site) %>%                   # Show Site name when clicked
clearControls() %>%
addLegend(position = "topright",
pal = pal,
values = ~Value,
title = input$param,
opacity = 1)
}
# Size
if(input$plot.type == "Display by Size"){
leafletProxy("map", data = df.react()) %>%
clearTiles() %>%
addProviderTiles(input$map.type,
options = providerTileOptions(noWrap = TRUE)) %>%
clearMarkers() %>%
addCircleMarkers(lng = ~LocationLong,
lat = ~LocationLat,
radius = ~value.scale()*sqrt(Value), # radius function of Value
weight = 2,                          # weight of the outside circle
color = input$color.static,          # Color of the outside circle
fillColor = input$color.static,      # User selected fill Color
fillOpacity = input$opacity,         # user selected opacity
label= ~as.character(Value),         # show Value when hovering
popup = ~Site) %>%                   # Show Site name when clicked
clearControls() %>%
addLegendCustom(colors = c(input$color.static, input$color.static, input$color.static),
labels = value.list(),
sizes = diam.list(),
opacity = .7)
}
# If no data, then clear the existing circleMarkers and legend
} else {
leafletProxy("map", data = df.react()) %>%
clearMarkers() %>%
clearControls()
}
})
} # end Server Funtion
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
# Set Library path for installantion
.libPaths("C:/Users/DCR-Tobiason/Documents/R/win-library/3.4")
# usage
ipak("shiny")
runApp()
runApp()
runApp()
runApp()
runApp()
base_break
?pretty_breaks
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
library(Kendall)
install.packages(Kendall)
install.packages("Kendall")
library(Kendall)
MannKendall(df.trib.quab$Date, df.trib.quab$Result)
MannKendall(df.trib.quab$Date)
df.trib.quab %>% filter(Site = "202")
df.trib.quab %>% filter(Site == "202")
factor(df.trib.quab$Site)
factor(df.trib.quab$Site)
df.trib.quab %>% filter(Site == "201")
levels(factor(df.trib.quab$Site))
df.trib.quab %>% filter(Site == "217")
hey <- df.trib.quab %>% filter(Site == "217")
MannKendall(hey)
MannKendall(hey$Date)
Kendall(hey$Date, hey$Result)
MannKendall(df.trib.quab$Date)
?geom_smooth
runApp()
runApp()
Kendall(hey$Date, hey$Result)
?ggsave
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
ipak <- function(pkg){
new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
if (length(new.pkg))
install.packages(new.pkg, dependencies = TRUE)
sapply(pkg, require, character.only = TRUE)
}
# Set Library path for installantion
.libPaths("C:/Users/DCR-Tobiason/Documents/R/win-library/3.4")
# usage
ipak("shiny")
runApp()
